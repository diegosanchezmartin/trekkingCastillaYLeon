'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vueInbrowserCompilerUtils = require('vue-inbrowser-compiler-utils');
var walkes = require('walkes');
var acorn = require('acorn');
var jsx = require('acorn-jsx');
var buble = require('buble');
var detectBrowser = require('detect-browser');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var walkes__default = /*#__PURE__*/_interopDefaultLegacy(walkes);
var jsx__default = /*#__PURE__*/_interopDefaultLegacy(jsx);

const extendedParser = acorn.Parser.extend(jsx__default["default"]());
function getAst(code) {
    return extendedParser.parse(code, {
        ecmaVersion: 2019,
        sourceType: 'module'
    });
}

function getImports(code) {
    const imports = [];
    try {
        const ast = getAst(code);
        walkes__default["default"](ast, {
            ImportDeclaration(node) {
                imports.push(node.source.value);
            },
            CallExpression(node) {
                if (node.callee.name === 'require' && node.arguments[0].value) {
                    imports.push(node.arguments[0].value);
                }
            }
        });
        return vueInbrowserCompilerUtils.isVue3 ? ['vue', ...imports] : imports;
    }
    catch (e) {
        return vueInbrowserCompilerUtils.isVue3 ? ['vue'] : [];
    }
}

const UNNAMED = /import\s*['"]([^'"]+)['"];?/gi;
const NAMED = /import\s*(\*\s*as)?\s*(\w*?)\s*,?\s*(?:\{([\s\S]*?)\})?\s*from\s*['"]([^'"]+)['"];?/gi;
function alias(previousKey) {
    let key = previousKey.trim();
    const name = key.split(' as ');
    if (name.length > 1) {
        key = name.shift() || '';
    }
    return { key, name: name[0] };
}
function generate(keys, dep, base, fn, offset = 0) {
    const depEnd = dep.split('/').pop();
    const tmp = depEnd
        ? depEnd.replace(/\W/g, '_') + '$' + offset // uniqueness
        : '';
    const name = alias(tmp).name;
    dep = `${fn}('${dep}')`;
    let obj;
    let out = `const ${name} = ${dep};`;
    if (base) {
        out += `const ${base} = ${tmp}.default || ${tmp};`;
    }
    keys.forEach(key => {
        obj = alias(key);
        out += `const ${obj.name} = ${tmp}.${obj.key};`;
    });
    return out;
}
function rewriteImports (str, offset, fn = 'require') {
    return str
        .replace(NAMED, (_, asterisk, base, req, dep) => generate(req ? req.split(',').filter((d) => d.trim()) : [], dep, base, fn, offset))
        .replace(UNNAMED, (_, dep) => `${fn}('${dep}');`);
}

function transformOneImport(node, code, offset) {
    const start = node.start + offset;
    const end = node.end + offset;
    const statement = code.substring(start, end);
    const transpiledStatement = rewriteImports(statement, offset);
    code = code.substring(0, start) + transpiledStatement + code.substring(end);
    offset += transpiledStatement.length - statement.length;
    return { code, offset };
}

const buildStyles = function (styles) {
    let _styles = '';
    if (styles) {
        styles.forEach(it => {
            if (it) {
                _styles += it;
            }
        });
    }
    if (_styles !== '') {
        return _styles.trim();
    }
    return undefined;
};
function getSingleFileComponentParts(code) {
    const parts = vueInbrowserCompilerUtils.parseComponent(code);
    if (parts.script) {
        parts.script = parts.script.replace(/\/\*[\s\S]*?\*\/|([^:]|^)\/\/.*$/gm, '$1');
    }
    return parts;
}
function parseScriptCode(code) {
    let preprocessing = '';
    let startIndex = -1;
    let endIndex = -1;
    let offset = 0;
    let renderFunctionStart = -1;
    walkes__default["default"](getAst(code), {
        //export const MyComponent = {}
        ExportNamedDeclaration(node, recurse, stop) {
            preprocessing = code.slice(0, node.start + offset);
            startIndex = node.declaration.declarations[0].init.start + offset;
            endIndex = node.declaration.declarations[0].init.end + offset;
            if (node.declarations) {
                renderFunctionStart = getRenderFunctionStart(node.declarations[0]);
            }
            recurse();
        },
        //export default {}
        ExportDefaultDeclaration(node, recurse, stop) {
            preprocessing = code.slice(0, node.start + offset);
            startIndex = node.declaration.start + offset;
            endIndex = node.declaration.end + offset;
            renderFunctionStart = getRenderFunctionStart(node.declaration);
            recurse();
        },
        //module.exports = {}
        AssignmentExpression(node, recurse, stop) {
            if (/exports/.test(node.left.name) ||
                (node.left.object &&
                    /module/.test(node.left.object.name) &&
                    /exports/.test(node.left.property.name))) {
                preprocessing = code.slice(0, node.start + offset);
                startIndex = node.right.start + offset;
                endIndex = node.right.end + offset;
            }
            recurse();
        },
        // and transform import statements into require
        ImportDeclaration(node) {
            const ret = transformOneImport(node, code, offset);
            offset = ret.offset;
            code = ret.code;
        }
    });
    if (startIndex === -1) {
        throw new Error('Failed to parse single file component: ' + code);
    }
    if (renderFunctionStart > 0 && !vueInbrowserCompilerUtils.isVue3) {
        renderFunctionStart += offset;
        code = insertCreateElementFunction(code.slice(0, renderFunctionStart + 1), code.slice(renderFunctionStart + 1));
        endIndex += JSX_ADDON_LENGTH;
    }
    const component = code.slice(startIndex + 1, endIndex - 1);
    return {
        preprocessing,
        component,
        postprocessing: code.slice(endIndex)
    };
}
const JSX_ADDON_LENGTH = 31;
function getRenderFunctionStart(objectExpression) {
    if (objectExpression && objectExpression.properties) {
        const nodeProperties = objectExpression.properties;
        const renderFunctionObj = nodeProperties.find((p) => p.key && p.key.type === 'Identifier' && p.key.name === 'render');
        if (renderFunctionObj && renderFunctionObj.value.body) {
            return renderFunctionObj.value.body.start;
        }
    }
    return -1;
}
function insertCreateElementFunction(before, after) {
    return `${before};const h = this.$createElement;${after}`;
}
/**
 * Coming out of this function all SFC should be in the `new Vue()` format
 * it should as well have been stripped of exports and all imports should have been
 * transformed into requires
 */
function normalizeSfcComponent(code) {
    const parts = getSingleFileComponentParts(code);
    const { preprocessing = '', component = '', postprocessing = '' } = parts.script ? parseScriptCode(parts.script) : {};
    return {
        template: parts.template,
        script: [preprocessing, `return {${component}}`, postprocessing].join('\n'),
        style: buildStyles(parts.styles)
    };
}

const browser = detectBrowser.detect();
const BROWSERS = {
    chrome: 71,
    firefox: 64,
    safari: 12,
    ie: 11,
    edge: 19
};
function isBubleBrowser(name) {
    return name in BROWSERS;
}
function getTargetFromBrowser() {
    if ((browser === null || browser === void 0 ? void 0 : browser.version) && (browser === null || browser === void 0 ? void 0 : browser.name)) {
        if (isBubleBrowser(browser.name)) {
            const version = parseInt(browser.version, 10);
            return {
                [browser.name]: version <= BROWSERS[browser.name] ? version : BROWSERS[browser.name]
            };
        }
    }
    return {};
}

/**
 * Reads the code as a string, separates the javascript part from the template & style parts,
 * then replaces the imports with requires and returns the script code as the body of a function.
 *
 * - For Vue2 the function compiles the template into a render function and adds the new function to the evaluated code.
 * - For Vue3 you have to use the compileVue3Template function yourself to compile the template into a function.
 * @param code
 * @param config buble config to be used when transforming
 *
 */
function compileVueCodeForEvalFunction(code, config = {}) {
    const nonCompiledComponent = prepareVueCodeForEvalFunction(code, config);
    const target = typeof window !== 'undefined' ? getTargetFromBrowser() : {};
    const compiledComponent = Object.assign(Object.assign({}, nonCompiledComponent), { script: buble.transform(nonCompiledComponent.script, Object.assign({ target }, config)).code });
    vueInbrowserCompilerUtils.compileTemplateForEval(compiledComponent);
    return Object.assign(Object.assign({}, compiledComponent), { raw: nonCompiledComponent });
}
function prepareVueCodeForEvalFunction(code, config) {
    let style;
    let vsgMode = false;
    let template;
    // if the component is written as a Vue sfc,
    // transform it in to a "return"
    // even if jsx is used in an sfc we still use this use case
    if (vueInbrowserCompilerUtils.isCodeVueSfc(code)) {
        return normalizeSfcComponent(code);
    }
    // if it's not a new Vue, it must be a simple template or a vsg format
    // lets separate the template from the script
    if (!/new Vue\(/.test(code)) {
        // this for jsx examples without the SFC shell
        // export default {render: (h) => <Button>}
        if (config.jsx) {
            const { preprocessing, component, postprocessing } = parseScriptCode(code);
            return {
                script: `${preprocessing};return {${component}};${postprocessing}`
            };
        }
        const findStartTemplateMatch = /^\W*</.test(code) ? { index: 0 } : code.match(/\n[\t ]*</);
        const limitScript = findStartTemplateMatch && findStartTemplateMatch.index !== undefined
            ? findStartTemplateMatch.index
            : -1;
        template = limitScript > -1 ? code.slice(limitScript) : undefined;
        code = limitScript > -1 ? code.slice(0, limitScript) : code;
        vsgMode = true;
    }
    const ast = getAst(code);
    let offset = 0;
    const varNames = [];
    walkes__default["default"](ast, Object.assign({ 
        // replace `new Vue({data})` by `return {data}`
        ExpressionStatement(node) {
            if (node.expression.type === 'NewExpression' && node.expression.callee.name === 'Vue') {
                const before = code.slice(0, node.expression.start + offset);
                const optionsNode = node.expression.arguments && node.expression.arguments.length
                    ? node.expression.arguments[0]
                    : undefined;
                const renderIndex = getRenderFunctionStart(optionsNode);
                let endIndex = optionsNode.end;
                if (renderIndex > 0 && !vueInbrowserCompilerUtils.isVue3) {
                    code = insertCreateElementFunction(code.slice(0, renderIndex + 1), code.slice(renderIndex + 1));
                    endIndex += JSX_ADDON_LENGTH;
                }
                const after = optionsNode ? code.slice(optionsNode.start + offset, endIndex + offset) : '';
                code = before + ';return ' + after;
            }
        },
        // transform all imports into require function calls
        ImportDeclaration(node) {
            const ret = transformOneImport(node, code, offset);
            offset = ret.offset;
            code = ret.code;
            if (vsgMode && node.specifiers) {
                node.specifiers.forEach((s) => varNames.push(s.local.name));
            }
        } }, (vsgMode
        ? {
            VariableDeclaration(node) {
                node.declarations.forEach((declaration) => {
                    if (declaration.id.name) {
                        // simple variable declaration
                        varNames.push(declaration.id.name);
                    }
                    else if (declaration.id.properties) {
                        // spread variable declaration
                        // const { all:names } = {all: 'foo'}
                        declaration.id.properties.forEach((p) => {
                            varNames.push(p.value.name);
                        });
                    }
                });
            },
            FunctionDeclaration(node) {
                varNames.push(node.id.name);
            }
        }
        : {})));
    if (vsgMode) {
        code += `;return {data:function(){return {${
        // add local vars in data
        // this is done through an object like {varName: varName}
        // since each varName is defined in compiledCode, it can be used to init
        // the data object here
        varNames.map(varName => `${varName}:${varName}`).join(',')}};}}`;
    }
    return {
        script: code,
        style,
        template
    };
}

Object.defineProperty(exports, 'adaptCreateElement', {
    enumerable: true,
    get: function () { return vueInbrowserCompilerUtils.adaptCreateElement; }
});
Object.defineProperty(exports, 'addScopedStyle', {
    enumerable: true,
    get: function () { return vueInbrowserCompilerUtils.addScopedStyle; }
});
Object.defineProperty(exports, 'compileTemplateForEval', {
    enumerable: true,
    get: function () { return vueInbrowserCompilerUtils.compileTemplateForEval; }
});
Object.defineProperty(exports, 'concatenate', {
    enumerable: true,
    get: function () { return vueInbrowserCompilerUtils.concatenate; }
});
Object.defineProperty(exports, 'isCodeVueSfc', {
    enumerable: true,
    get: function () { return vueInbrowserCompilerUtils.isCodeVueSfc; }
});
Object.defineProperty(exports, 'parseComponent', {
    enumerable: true,
    get: function () { return vueInbrowserCompilerUtils.parseComponent; }
});
exports.compile = compileVueCodeForEvalFunction;
exports.getImports = getImports;
