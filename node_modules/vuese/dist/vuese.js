'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var vueTemplateCompiler = require('vue-template-compiler');
var parser = require('@babel/parser');
var generate = _interopDefault(require('@babel/generator'));
var bt = require('@babel/types');
require('fs');
var traverse = _interopDefault(require('@babel/traverse'));
var util = require('util');

function sfcToAST (source, babelParserPlugins) {
    const sfc = vueTemplateCompiler.parseComponent(source);
    const res = {};
    if (sfc.script && sfc.script.content) {
        res.sourceType = sfc.script.lang || 'js';
        res.jsAst = parser.parse(sfc.script.content, {
            sourceType: 'module',
            plugins: babelParserPlugins || [
                'objectRestSpread',
                'dynamicImport',
                'decorators-legacy',
                'classProperties',
                'typescript'
            ]
        });
    }
    if (sfc.template && sfc.template.content) {
        res.templateAst = vueTemplateCompiler.compile(sfc.template.content, {
            comments: true
        }).ast;
    }
    return res;
}

/**
 * If a node satisfies the following conditions, then we will use this node as a Vue component.
 * 1. It is a default export
 * 2. others...
 */
function isVueComponent(node) {
    return bt.isExportDefaultDeclaration(node);
}
function isCommentLine(node) {
    return node.type === 'CommentLine';
}
function isCommentBlock(node) {
    return node.type === 'CommentBlock';
}
function runFunction(fnCode) {
    const { code: genCode } = generate(fnCode);
    const code = `return (${genCode})()`;
    const fn = new Function(code);
    try {
        return fn();
    }
    catch (e) {
        console.error(e);
    }
}
function getValueFromGenerate(node) {
    let code = 'return';
    const { code: genCode } = generate(node);
    code += genCode;
    const fn = new Function(code);
    try {
        return fn();
    }
    catch (e) {
        console.error(e);
    }
}
function isVueOption(path, optionsName) {
    if (bt.isObjectProperty(path.node) &&
        path.parentPath &&
        path.parentPath.parentPath &&
        isVueComponent(path.parentPath.parentPath.node)) {
        return path.node.key.name === optionsName;
    }
    else if (bt.isObjectProperty(path.node) &&
        path.parentPath &&
        path.parentPath.parentPath &&
        bt.isCallExpression(path.parentPath.parentPath.node) &&
        path.parentPath.parentPath.node.callee.name ===
            'Component' &&
        path.parentPath.parentPath.parentPath &&
        bt.isDecorator(path.parentPath.parentPath.parentPath.node)) {
        // options in ts @Component({...})
        return path.node.key.name === optionsName;
    }
    return false;
}
function getEmitDecorator(decorators) {
    if (!decorators || !decorators.length)
        return null;
    for (let i = 0; i < decorators.length; i++) {
        const exp = decorators[i].expression;
        if (bt.isCallExpression(exp) &&
            bt.isIdentifier(exp.callee) &&
            exp.callee.name === 'Emit') {
            return decorators[i];
        }
    }
    return null;
}
function getArgumentFromPropDecorator(classPropertyNode) {
    const decorators = classPropertyNode.decorators;
    if (decorators) {
        for (let i = 0; i < decorators.length; i++) {
            const deco = decorators[i];
            if (bt.isCallExpression(deco.expression) &&
                bt.isIdentifier(deco.expression.callee) &&
                deco.expression.callee.name === 'Prop') {
                return deco.expression.arguments[0];
            }
        }
    }
    return null;
}

const commentRE = /\s*\*\s*/g;
const leadRE = /^@(\w+)\b/;
function getComments(cnode) {
    const res = {
        default: []
    };
    const commentNodes = cnode.leadingComments || [];
    if (!commentNodes || !commentNodes.length)
        return res;
    let comments = '', matchs;
    commentNodes.forEach((node) => {
        if (isCommentLine(node)) {
            comments = node.value.trim();
            matchs = comments.match(leadRE);
            if (matchs) {
                const key = matchs[1];
                res[key] = res[key] || [];
                res[key].push(comments.replace(leadRE, ''));
            }
            else {
                res.default.push(comments);
            }
        }
        else if (isCommentBlock(node)) {
            comments = node.value
                .replace(commentRE, '\n')
                .replace(/^\*/, '')
                .split('\n')
                .filter(t => t)
                .join('\n')
                .trim();
            let currentKey = 'default';
            comments.split('\n').forEach(c => {
                if ((matchs = c.match(leadRE))) {
                    currentKey = matchs[1];
                    res[currentKey] = res[currentKey] || [];
                    res[currentKey].push(c.replace(leadRE, '').trim());
                }
                else {
                    res.default.push(c);
                }
            });
        }
    });
    return res;
}

function parseJavascript (ast, options = {}) {
    const seenEvent = new Set();
    traverse(ast, {
        ExportDefaultDeclaration(path) {
            path.traverse({
                ObjectProperty(path) {
                    const { onProp, onMethod, onName } = options;
                    // Processing name
                    if (isVueOption(path, 'name')) {
                        if (onName)
                            onName(path.node.value.value);
                    }
                    // Processing props
                    if (isVueOption(path, 'props')) {
                        const valuePath = path.get('value');
                        if (bt.isArrayExpression(valuePath.node)) {
                            // An array of strings
                            const propsValue = getValueFromGenerate(valuePath.node);
                            const propsRes = normalizeProps(propsValue);
                            propsRes.forEach(prop => {
                                if (onProp)
                                    onProp(prop);
                            });
                        }
                        else if (bt.isObjectExpression(valuePath.node)) {
                            // An object
                            valuePath.traverse({
                                ObjectProperty(propPath) {
                                    // Guarantee that this is the prop definition
                                    if (propPath.parentPath === valuePath) {
                                        const name = propPath.node.key.name;
                                        const propValueNode = propPath.node.value;
                                        const result = {
                                            name,
                                            type: null,
                                            describe: getComments(propPath.node).default
                                        };
                                        processPropValue(propValueNode, result);
                                        if (onProp)
                                            onProp(result);
                                    }
                                }
                            });
                        }
                    }
                    // Processing methods
                    if (isVueOption(path, 'methods')) {
                        const properties = path.node
                            .value.properties.filter(n => bt.isObjectMethod(n) || bt.isObjectProperty(n));
                        properties.forEach(node => {
                            const commentsRes = getComments(node);
                            // Collect only methods that have @vuese annotations
                            if (commentsRes.vuese) {
                                const result = {
                                    name: node.key.name,
                                    describe: commentsRes.default,
                                    argumentsDesc: commentsRes.arg
                                };
                                if (onMethod)
                                    onMethod(result);
                            }
                        });
                    }
                },
                CallExpression(path) {
                    const node = path.node;
                    // this.$emit()
                    if (bt.isMemberExpression(node.callee) &&
                        bt.isThisExpression(node.callee.object) &&
                        bt.isIdentifier(node.callee.property) &&
                        node.callee.property.name === '$emit' &&
                        bt.isExpressionStatement(path.parentPath.node)) {
                        const { onEvent } = options;
                        const args = node.arguments;
                        const result = {
                            name: ''
                        };
                        const firstArg = args[0];
                        if (args.length && bt.isStringLiteral(firstArg)) {
                            result.name = firstArg.value;
                        }
                        if (!result.name || seenEvent.has(result.name))
                            return;
                        seenEvent.add(result.name);
                        const allComments = getComments(path.parentPath.node);
                        result.describe = allComments.default;
                        result.argumentsDesc = allComments.arg;
                        if (onEvent)
                            onEvent(result);
                    }
                }
            });
        },
        // Class style component
        ClassProperty(path) {
            const propDecoratorArg = getArgumentFromPropDecorator(path.node);
            if (!propDecoratorArg)
                return;
            const result = {
                name: path.node.key.name,
                type: null,
                describe: getComments(path.node).default
            };
            processPropValue(propDecoratorArg, result);
            if (options.onProp)
                options.onProp(result);
        },
        ClassMethod(path) {
            const node = path.node;
            const commentsRes = getComments(node);
            // Collect only methods that have @vuese annotations
            if (commentsRes.vuese) {
                const result = {
                    name: node.key.name,
                    describe: commentsRes.default,
                    argumentsDesc: commentsRes.arg
                };
                if (options.onMethod)
                    options.onMethod(result);
            }
            // @Emit
            const emitDecorator = getEmitDecorator(node.decorators);
            if (emitDecorator) {
                const result = {
                    name: ''
                };
                const args = emitDecorator.expression.arguments;
                if (args && args.length && bt.isStringLiteral(args[0])) {
                    result.name = args[0].value;
                }
                else {
                    if (bt.isIdentifier(node.key)) {
                        result.name = node.key.name.replace(/([A-Z])/g, '-$1').toLowerCase();
                    }
                }
                if (!result.name || seenEvent.has(result.name))
                    return;
                seenEvent.add(result.name);
                const allComments = getComments(node);
                result.describe = allComments.default;
                result.argumentsDesc = allComments.arg;
                if (options.onEvent)
                    options.onEvent(result);
            }
        }
    });
}
function normalizeProps(props) {
    return props.map(prop => ({
        type: null,
        name: prop
    }));
}
function getTypeByTypeNode(typeNode) {
    if (bt.isIdentifier(typeNode))
        return typeNode.name;
    if (bt.isArrayExpression(typeNode)) {
        if (!typeNode.elements.length)
            return null;
        return typeNode.elements
            .filter(node => node && bt.isIdentifier(node))
            .map(node => node.name);
    }
    return null;
}
// The `type` of a prop should be an array of constructors or constructors
// eg. String or [String, Number]
function isAllowPropsType(typeNode) {
    return bt.isIdentifier(typeNode) || bt.isArrayExpression(typeNode);
}
function hasFunctionTypeDef(type) {
    if (typeof type === 'string') {
        return type.toLowerCase() === 'function';
    }
    else if (util.isArray(type)) {
        return type.map(a => a.toLowerCase()).some(b => b === 'function');
    }
    return false;
}
function processPropValue(propValueNode, result) {
    if (isAllowPropsType(propValueNode)) {
        result.type = getTypeByTypeNode(propValueNode);
    }
    else if (bt.isObjectExpression(propValueNode)) {
        if (!propValueNode.properties.length)
            return;
        const allPropNodes = propValueNode.properties;
        const typeNode = allPropNodes.filter((node) => {
            if (node.key.name === 'type') {
                return true;
            }
            return false;
        });
        const otherNodes = allPropNodes.filter((node) => {
            if (node.key.name !== 'type') {
                return true;
            }
            return false;
        });
        // Prioritize `type` before processing `default`.
        // Because the difference in `type` will affect the way `default` is handled.
        if (typeNode.length > 0) {
            result.type = getTypeByTypeNode(typeNode[0].value);
            // Get descriptions of the type
            const typeDesc = getComments(typeNode[0]).default;
            if (typeDesc.length > 0) {
                result.typeDesc = typeDesc;
            }
        }
        otherNodes.forEach((node) => {
            const n = node.key.name;
            if (n === 'default') {
                if (!hasFunctionTypeDef(result.type) && bt.isFunction(node.value)) {
                    result.default = runFunction(node.value);
                }
                else {
                    if (bt.isObjectMethod(node)) {
                        result.default = generate(node).code;
                    }
                    else {
                        result.default = generate(node.value).code;
                    }
                }
                // Get descriptions of the default value
                const defaultDesc = getComments(node).default;
                if (defaultDesc.length > 0) {
                    result.defaultDesc = defaultDesc;
                }
            }
            else if (n === 'required') {
                if (bt.isBooleanLiteral(node.value)) {
                    result.required = node.value.value;
                }
            }
            else if (n === 'validator') {
                if (bt.isObjectMethod(node)) {
                    result.validator = generate(node).code;
                }
                else {
                    result.validator = generate(node.value).code;
                }
                // Get descriptions of the validator
                const validatorDesc = getComments(node).default;
                if (validatorDesc.length > 0) {
                    result.validatorDesc = validatorDesc;
                }
            }
        });
    }
}

function traverse$1(templateAst, options) {
    const parent = templateAst.parent;
    if (templateAst.type === 1) {
        if (templateAst.tag === 'slot') {
            const slot = {
                name: 'default',
                describe: '',
                backerDesc: '',
                bindings: {}
            };
            slot.bindings = extractAndFilterAttr(templateAst.attrsMap);
            if (slot.bindings.name) {
                slot.name = slot.bindings.name;
                delete slot.bindings.name;
            }
            if (parent) {
                const list = parent.children;
                let currentSlotIndex = 0;
                for (let i = 0; i < list.length; i++) {
                    let el = list[i];
                    if (el === templateAst) {
                        currentSlotIndex = i;
                        break;
                    }
                }
                // Find the first leading comment node as a description of the slot
                const copies = list.slice(0, currentSlotIndex).reverse();
                for (let i = 0; i < copies.length; i++) {
                    let el = copies[i];
                    if (el.type !== 3 || (!el.isComment && el.text.trim()))
                        break;
                    if (el.isComment &&
                        !(parent.tag === 'slot' && parent.children[0] === el)) {
                        slot.describe = el.text.trim();
                        break;
                    }
                }
                // Find the first child comment node as a description of the default slot content
                if (templateAst.children.length) {
                    for (let i = 0; i < templateAst.children.length; i++) {
                        let el = templateAst.children[i];
                        if (el.type !== 3 || (!el.isComment && el.text.trim()))
                            break;
                        if (el.isComment) {
                            slot.backerDesc = el.text.trim();
                            break;
                        }
                    }
                }
            }
            if (options.onSlot)
                options.onSlot(slot);
        }
        for (let i = 0; i < templateAst.children.length; i++) {
            traverse$1(templateAst.children[i], options);
        }
    }
}
const dirRE = /^(v-|:|@)/;
const allowRE = /^(v-bind|:)/;
function extractAndFilterAttr(attrsMap) {
    const res = {};
    const keys = Object.keys(attrsMap);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (!dirRE.test(key) || allowRE.test(key)) {
            res[key.replace(allowRE, '')] = attrsMap[key];
        }
    }
    return res;
}

function parser$1 (source, options = {}) {
    const astRes = sfcToAST(source, options.babelParserPlugins);
    const res = {};
    const defaultOptions = {
        onName(name) {
            res.name = name;
        },
        onProp(propsRes) {
            if (propsRes) {
                (res.props || (res.props = [])).push(propsRes);
            }
        },
        onEvent(eventsRes) {
            if (eventsRes) {
                (res.events || (res.events = [])).push(eventsRes);
            }
        },
        onSlot(slotRes) {
            if (slotRes) {
                (res.slots || (res.slots = [])).push(slotRes);
            }
        },
        onMethod(methodRes) {
            if (methodRes) {
                (res.methods || (res.methods = [])).push(methodRes);
            }
        },
        babelParserPlugins: [
            'objectRestSpread',
            'dynamicImport',
            'decorators-legacy',
            'typescript'
        ]
    };
    const finallyOptions = Object.assign(defaultOptions, options);
    if (astRes.jsAst) {
        parseJavascript(astRes.jsAst, finallyOptions);
    }
    if (astRes.templateAst) {
        traverse$1(astRes.templateAst, finallyOptions);
    }
    return res;
}

class Render {
    constructor(res, options) {
        this.res = res;
        this.options = options;
        this.options = Object.assign({}, {
            props: ['Name', 'Description', 'Type', 'Required', 'Default'],
            events: ['Event Name', 'Description', 'Parameters'],
            slots: ['Name', 'Description', 'Default Slot Content'],
            methods: ['Method', 'Description', 'Parameters']
        }, this.options);
    }
    render() {
        const { props, slots, events, methods } = this.res;
        let md = {};
        if (props) {
            md.props = this.propRender(props);
        }
        if (slots) {
            md.slots = this.slotRender(slots);
        }
        if (events) {
            md.events = this.eventRender(events);
        }
        if (methods) {
            md.methods = this.methodRender(methods);
        }
        return md;
    }
    propRender(propsRes) {
        const propConfig = this.options.props;
        let code = this.renderTabelHeader(propConfig);
        propsRes.forEach((prop) => {
            const row = [];
            for (let i = 0; i < propConfig.length; i++) {
                if (propConfig[i] === 'Name') {
                    row.push(prop.name);
                }
                else if (propConfig[i] === 'Description') {
                    let desc = ['-'];
                    if (prop.describe && prop.describe.length) {
                        desc = prop.describe;
                        if (prop.validatorDesc) {
                            desc = prop.describe.concat(prop.validatorDesc);
                        }
                    }
                    row.push(desc.join(''));
                }
                else if (propConfig[i] === 'Type') {
                    if (prop.typeDesc) {
                        row.push(prop.typeDesc.join(''));
                    }
                    else if (!prop.type) {
                        row.push('—');
                    }
                    else if (typeof prop.type === 'string') {
                        row.push(`\`${prop.type}\``);
                    }
                    else if (Array.isArray(prop.type)) {
                        row.push(prop.type
                            .map(t => `\`${t}\` / `)
                            .join('')
                            .slice(0, -3));
                    }
                    else {
                        row.push('-');
                    }
                }
                else if (propConfig[i] === 'Required') {
                    if (typeof prop.required === 'undefined') {
                        row.push('`false`');
                    }
                    else if (typeof prop.required === 'boolean') {
                        row.push(`\`${String(prop.required)}\``);
                    }
                    else {
                        row.push('-');
                    }
                }
                else if (propConfig[i] === 'Default') {
                    if (prop.defaultDesc) {
                        row.push(prop.defaultDesc.join(''));
                    }
                    else if (prop.default) {
                        row.push(prop.default);
                    }
                    else {
                        row.push('-');
                    }
                }
                else {
                    row.push('-');
                }
            }
            code += this.renderTabelRow(row);
        });
        return code;
    }
    slotRender(slotsRes) {
        const slotConfig = this.options.slots;
        let code = this.renderTabelHeader(slotConfig);
        slotsRes.forEach((slot) => {
            const row = [];
            for (let i = 0; i < slotConfig.length; i++) {
                if (slotConfig[i] === 'Name') {
                    row.push(slot.name);
                }
                else if (slotConfig[i] === 'Description') {
                    if (slot.describe) {
                        row.push(slot.describe);
                    }
                    else {
                        row.push('-');
                    }
                }
                else if (slotConfig[i] === 'Default Slot Content') {
                    if (slot.backerDesc) {
                        row.push(slot.backerDesc);
                    }
                    else {
                        row.push('-');
                    }
                }
                else {
                    row.push('-');
                }
            }
            code += this.renderTabelRow(row);
        });
        return code;
    }
    eventRender(propsRes) {
        const eventConfig = this.options.events;
        let code = this.renderTabelHeader(eventConfig);
        propsRes.forEach((event) => {
            const row = [];
            for (let i = 0; i < eventConfig.length; i++) {
                if (eventConfig[i] === 'Event Name') {
                    row.push(event.name);
                }
                else if (eventConfig[i] === 'Description') {
                    if (event.describe && event.describe.length) {
                        row.push(event.describe.join(''));
                    }
                    else {
                        row.push('-');
                    }
                }
                else if (eventConfig[i] === 'Parameters') {
                    if (event.argumentsDesc) {
                        row.push(event.argumentsDesc.join(''));
                    }
                    else {
                        row.push('-');
                    }
                }
                else {
                    row.push('-');
                }
            }
            code += this.renderTabelRow(row);
        });
        return code;
    }
    methodRender(slotsRes) {
        const methodConfig = this.options.methods;
        let code = this.renderTabelHeader(methodConfig);
        slotsRes.forEach((method) => {
            const row = [];
            for (let i = 0; i < methodConfig.length; i++) {
                if (methodConfig[i] === 'Method') {
                    row.push(method.name);
                }
                else if (methodConfig[i] === 'Description') {
                    if (method.describe) {
                        row.push(method.describe.join(''));
                    }
                    else {
                        row.push('-');
                    }
                }
                else if (methodConfig[i] === 'Parameters') {
                    if (method.argumentsDesc) {
                        row.push(method.argumentsDesc.join(''));
                    }
                    else {
                        row.push('-');
                    }
                }
                else {
                    row.push('-');
                }
            }
            code += this.renderTabelRow(row);
        });
        return code;
    }
    renderTabelHeader(header) {
        const headerString = this.renderTabelRow(header);
        const splitLine = this.renderSplitLine(header.length);
        return headerString + splitLine + '\n';
    }
    renderTabelRow(row) {
        return row.map(n => `|${n}`).join('') + '|\n';
    }
    renderSplitLine(num) {
        let line = '';
        for (let i = 0; i < num; i++) {
            line += '|---';
        }
        return line + '|';
    }
}

var index = {
    parser: parser$1,
    Render
};

module.exports = index;
